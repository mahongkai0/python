map
L=[1,2,3,4]
L =map(int,L) 全部转成


day10 回顾
全局  
1.一旦创建 不会自动销毁  需要用del语句销毁

局部
 在函数调用时（过程中     ） 自动销毁
 globals         /locals
globals
返回全局避暑纳凉的字典 
locals
返回局部变量的字典
 函数变量 
 函数名时变量 它在创建时绑定一个函数 
  函数可以作为形参传入另一个函数
  函数可以作为另一个函数的返回值
  函数嵌套定义

 作用域
 局部
 外部嵌套函数作用域
 全局  （模块内）
 内建（内置）函数作用域

global  语句
声明 为全局作用域
global  V


nonlocal 语句
声明为外部嵌套函数作用域
lambda

创建函数的表达式
主要是用来创建简单函数



eval 函数
把字符串当成表达式  返回表达式的执行结果

exec
把字符串当成 python语言的程序来运行









day11

函数式编程  functional programming

    函数式编程时指用一些列的函数解决问题
说明：
  用每一个函数完成细小的功能   一系列函数任意组成可以解决大问题
  函数仅接受输入并产生输出  不包含任何能影响输出的内部状态

示例见：

s = sum(range(1,x+1))


函数的可重复性
    当一个函数没有访问除局部变量以外的变量 则此函数为可重入函数
特点：

    输入一定  结果必须一定

示例
 myadd（x，y）:           #此函数没有访问全局或外部嵌套函数的变量
    print(x + y)
print（myadd（100,200））

#以下为不可重入函数
s= 0
def myadd（x，y）：
    print(x +y+s)      注s为全局变量
print(myadd（100，200）)           #300

s = 10000
print(myadd（100，200）)  


高阶函数   hight Order functiona

    什么是高阶函数
    满足下列条件中一个函数 即为高阶函数
函数接受一个或多个函数作为参数传入
函数返回一个函数

python 内建的高阶函数
map   filter sorted

map函数  格式：

map（func，interablel，iterable2，...）

作用：用interable1,iterable2 中取出来的数据用func处理后返回
     处理后的结果
参数：
    func 数据处理函数
    iterable1，iterable2  可以迭代对象
返回值：    ##############################################################################
    可迭代对象
示例
def power2(x):
    return x **2
for x in map(power2,range(1,10)):                      #####先给range要  power 不加括号为 调用整个函数
    print(x)

说明：
func函数的形参列表的形参个数与可迭代对象的个数
相关，一般func函数的形参个数等于map函数中的可迭代对象的个数、

示例 ：
生成一个可迭代对象  此可迭代可以生成
1 ** 4   2 **3   3 ** 2  4 **1
pow（x，y，Z=none）
for x in map(pow,[1,2,3,4],{4,3,2,1})
后面长度不够 也就是短的可迭代对象  长度为几生成几个数



filter  函数

格式：
    filter（func，iterable）
作用：
创建一个可迭代对象，此可迭代对象将用func 函数对iterable中的数据  进行筛选
参数：
    func 筛选函数   有一个形参 通常返回 True / false  


iterable   原始的可迭代数据
返回值：
可迭代对象
示例:

def isodd（x）：
    '''此函数判断x是否为奇数，如果奇数返回True'''
    return x % 2 == 1

打印1到10 以内的奇数
for x in filter(isodd,range(10)):
    print(x)


生成10 以内所ou数的列表
L= list（filter(lambda x : x % 2 ==0),range(10)）


sorted 函数
作用：
 将原可迭代对象的数据进行排序 生成排序后的列表
 格式：
    sorted(iterable,key = None,reverse=False)
参数：
    iterable 可迭代对象
    key 函数  用来提供一个排序的依据值 默认用原值进行比较 
    key 函数 传入的是要比较的数据对像  返回值为能进行比较的值
    reverse 标志用来设置是否降序
返回值 
排序后的列表

示例见：L =【5，-2，-4,0,3,1】
L2 = sorted(L)  #L2 =[-4,-2,0,1,3,5]
L3= sorted(L,reverse =True)  降序排列

L4 = sorted(L.....) 想依据绝对值排列 如
L4 = （sorted(L,key = abs）


key 函数的格式

def xxx(a[需要比较的数据])：
    return a的依据

示例
names = ['tom','j','Spike','tykee']
sorted（names） ['j','Spike','tom','tyke']
 
sorted(names,key = len)


小结
三个高阶函数

map(func 可迭代对象1，可迭代对象2)
    对一个或多个可迭代对象的数据处理
filter（func，可迭代对象）
    过滤
sorted  （可迭代对象，key = 函数，reverse =False）
    排序


递归      Recursion
    递归是指函数直接或间接的调用自身

示意
def ff（）：
    ff（）
ff() 


        ##########直接调用自身



####################################
def fa（):
    fb()
def fb():
    fa()
fa()         ####  间接调用
###################################################

说明：

    递归一定要控制递归的层数  当符合一定条件时  要终止递归
    几乎所有的递都能用whil循环来代替
递归分为两个阶段  
    递推阶段：
        从原位置出发  按递归公式 从未知到已知，最终返回
    回归阶段
        按递归终止条件 逆向代入递归公式  回归到原问题求解


问题 
局部变量在什么时候自动销毁
   函数结束后才自动销毁（如果函数尚未结束则局部变量不会销毁）
同一个函数能有几个同名的局部变量？

    调用几次就有几个局部变量
示例

递归一定要控制递归的层数 当符合某一条件时 要终止递归调用
优点：
    递归可以把问题简单化 让思路更清晰 代码更简洁
缺点：
    低估因系统环境影响大 当递归深度太大时  可能会得到不可预知的后果

    
闭包 closure

什么是闭包
    闭包是指引用了此函数外部嵌套函数的变量的函数

闭包必须满足三个条件：
1.必须有一个内嵌函数
2.内嵌函数必须引用外部函数中的变量
3.外部函数返回值必须是嵌套函数

思考：
全局变量和局部变量的区别
    全局变量
        一直存在 谁都可以访问和修改
    局部变量 
        只是在调用时存在 只能在函数内部进行访问和修改
    
示例见 
    

优缺点：
  优点：
    加强封装性，用内部嵌套函数可以使用函数之外的变量而不会被
    破坏
  缺点
    由于闭包会使得函数中的变量都被保存在内存中  内存消耗量大  
    所以不能滥用闭包
    





















































































































































































