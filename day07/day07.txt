
day06回顾

列表 索引和切片


取值
v = 列表【整数表达式】
lst2 = 列表【开始 ：结束：步长】 #返回列表

赋值
列表【整数表达式】 = v
列表【开始：结束：步长】 = 可迭代对象
del 语句
del 列表  【整数表达式】
del 列表【开始：结束:步长】

函数 
reversed（x） 将可迭代对象反转 返回另一个可迭代对象

如： L2 = list(reversed（S）)
sorted（x reverse= False） 默认为升序排序

L.append（x） 追加
L.extenf（可迭代对象）  作用类似 L2 += (可跌代对象)
L.count（x）
l.COPY()
l.remove（） 删除
L.pop（【索引】） 移除（取出返回取出来的数据）



深拷贝和浅拷贝
不拷贝 L2 =L1 两个变量同时绑定同一个对象
浅拷贝
L2 = L1.copy（）   或L2 = L1[::]      只复制一层 深层对象共同拥有

深拷贝
import copy()
L2 = copy.deepcopy(L1)  复制整数树形关联的对象

文件解析方法
s.split(sep =None)
s.splitlines()
 要加的东西.join(字符串可迭代对象)


day07


元组 tuple                                  str        list可变      tuple    bytes       butearray  可变
  1. 元组是不可以改变的序列   同list一样，元祖可以存放任意类型数据的容器
  2.可以认为  元组是不可变的列表

元组的表示方法：
用小括号（） 括起来 单个元素括起来加逗号（，） 号区分元组还是单个元素
创建空元组
（）   #创建一个空元组
创建一个非空元组：
t = 100,
t =(200,)
t = (1,2,3)
t = 100,200,300
注：type  函数可以返回x的类型

元组的错误示例：
 t = (20)    t绑定20这个整数  不是元组
 x ,y ,z  = 100,200,300                   #序列赋值 不是元组
x ,y ,z  = [100,200,300 ] 
x ,y ,z  = (100,200,300)
x,y,z = "ABC"
x,y = y,x    序列赋值实现交换

元组的构造函数
tuple() 生成一个空的元组 等同于（）
tuple(iterable)  用可迭代对象生成一个元组
例子：
t = tuple()
t = tuple("as")
t = tuple("range(1,10,3)")
t = tuple([2,3,5,7])

元组是可迭代对象
t =tuple("ABC")
for x in t:
    print(t)
L = [x for x in t] 

元组的运算

算术运算：
  +  +=  *   *+
  用法等同于字符串的算术运算
  如：
  t= (1,2,3)+(4,5,6)
  t += (7,8,9)                   此处t绑定的对象的id会变化
  t = (1,2,3) * 2
  t *= 3

元组的 in/ not in  运算符
判断一个值是否存在于元组中  如果存在返回true 否则返回false
与列表的 in /not in 功能相同
索引  index
用法等同于列表的索引
注 元组不支持索引赋值
切片：
用法与列表的切片用法相同
元组的切片返回一个新的元组
元组不能切片赋值
元组的方法：

T.index(v[,begin[,end]])  返回对应元素的索引下标   begin 为开始索引 end为结束索引  当V 不存在时会触发 ValueError
                              类型的错误
T.count（x）    返回元组中对应的元素个数


三种序列
str               不可变
list              可变

tuple            不可变

有先后顺序关系
能用于序列的函数总结：



len（x） max(x)
min (x)  


sum(x)   这三个不可对字符串操作              
any(x)  all(x) 
  
构造函数
str(x)    tuple(x)   list(x)

reversed（x）   sorted（x，reverse = False）

字典  dict
    什么是字典
    1.字典是一种可变的容器  可以存储任意类型的数据
    2.字典中的每个数据都是用 “键”（key） 进行索引 而不像序列
          （字符串 列表等） 可以用整数下标进行索引
    3.字典内的数据没有先后顺序关系  字典的存储时无序的
    4.字典中的数据以键（key）-值（value） 对的形式进行映射存储
    5.字典的键不能重复 且只能用不可变类型作为字典的键
字典的字面值表示方法
字典是以{}括起来的  以冒号（：）分隔键值对 ，各键-值对之间用逗号分隔
创建空字典：
d = {}
创建非空字典
d = {'姓名': 'tarena', '年龄': 15}
d = {1:'一', 2:'二',3: '三'}

d = {'a': {'b':100, 'c': 200}}
d = {'name':None}

d = {tuple(range(4)): list(range(4))}
d = {1:'一':,2:'二':,1:'d' }
重复的键只能留一个 通常留后面的
字典的构造函数 dict
dict（）  创建一个空的字典 等突破年华语{}
dict（iterable） 用可迭代对象初初始化一个字典
dict（**kwargs）关键字传参形式生成一个字典
示例：
d = dict（）     # d = {}
L={（1,2），【3,4】，”AB“】 都为一对且是序列
d = dict(L)
 # d = {1:2,3:4,'A':'B'}  
 d = {name='tarena', age = 15}
注：
关键字传参时，关键字的名字必须是符合标示符命名规则的 字符串


字典的键（key）必须是不可变的类型
int float bool complex str tuple
frozenset（固定集合）和bytes（后面才学）
和None对象

可变的数据类型
list，dict，set（集合） bytearray（字节组合）

字典的键索引
用[]运算符可以获取字典内的键 对应的值
语法：
v = 字典[键]
示例：
d = {'name': 'tarena', 'age': 20}
    print(d['name'],'今年', d['age'],'岁')


添加和修改字典的元素
语法：
  字典【键】 = 值 
  说明：
  如果键不存在 创建键  并绑定键对应的值 
  键存在，修改键绑定的值

d = {}
d['name'] = 'tarena'   #创建‘name’  键  对应‘tarena’
d['age'] = 15  # 创建‘age’  键  绑定15
d【‘age’】 = 16   #修改‘age’键  绑定为16
print（d）     #       



del 语句
删除字典的键    同时解除与值得绑定关系
语法：
del 字典（键）
示例：
d = {'name': 'tarena', 'age':15}
del d['name'] #删除 'name'键

字典的成员资格判断  in / not in
可以用  in 运算符来判断一个键是否存在于字典中 如果存在则返回true  负责返回false
not in 与in相反
示例：
d = {1：‘一’,'aaa':'三个a'}
1 in d  #######True
‘一’  in d  #False
2 not in d  #True
'三个a' not in  d  True


字典的迭代访问
  字典是可迭代对象，字典只能对键进行迭代访问
  示例：
d = {'一':1,'二': 2,'三':3}
for key in d:
    print("键",key,"值",d(key))



字典的比较
 ==  !=           #########>  >=  <  <= 
==   字典是否完全相同

!= 与== 返回值相反
>  
{'一':1,'二': 2,'三':3} == {'二':2,'一': 1,'三':3}       True
{'一':1,'二': 2,'三':3} == {'二':2,'一': 1,'三':3.14}       False



可以用于字典的内建函数


len（seq） 返回字典的键值得个数
max（x）  返回字典的键的最大值
min（x） 返回字典的键的最小值
sum（x）   返回字典中所有键的和
any（x）  真值测试  如果字典中其中一个值为真值 则返回True
all（x）  真值测试，如果字典中所有的值都为真值才返回True否则返回false


示例：
d = {0:'零',5:'伍',8:'捌',3:'叁'}
len（d)         4
max(d)      8
min(d)     0
sum(d)       16
any(d)          True
all(d)        False

z字典的方法


for key in d.keys():
    print(key)
把所有的键拿出来


例子 ：
d1 = {1:'one',2:'二',3:'三'}
for t in d1.items():
    print()        ####(1,'one')  (2,'二') (3,'三')
    
for 语句的句法

for 变量列表  in 可迭代对象：
    语句
for k， v in dl.items（）：
    print（”键：“，看，‘值’, v）



字典推导式
字典推导式是用可迭代对象一次生成字典内元素的表达式
语法：
{键表达式： 值表达式 for 变量 in 可迭代对象 [if 真值表达式]}
注： 【】代表内部的内容可省略
示例：
生成一个字典  键为数字（1·9）  值为键的平方
a = {x : x ** 2  for x in range(1,10) }



字典推导式的嵌套
规则同类表的推导式


字典  vs 列表

1.都是可变对象
2.索引方式不同   列表用整数索引  字典用键索引
3.字典的插入 删除 修改的速度可能会快于列表（重要）
4.列表的存储是有序的 字典的存储是无序的























































































































