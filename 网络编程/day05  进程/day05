前期回顾

1.poll方法实现的IO多路复用
p = poll #创建poll对象
p.register()  关注IO
p.unregister()  取消关注
p.poll（） 使用poll方法

2.epoll方法 
* 效率更高
* 触发方式更多（EPOLLET）
* 能够监控更多的IO
3.struct
功能  将一组数据结构化转换为bytes 或者将字节串解析成元组

4.本地套接字
功能：用于本地两个数据进程间通信
sockfd = pack.(AF_UNXI,SOCK_STREAM)

5.并发 和并行
进程的状态  等待态  运行态  就绪态


6.os.fork（） 创建新的进程
 

!************************************************************************************************************



fork()创建子进程的特点
1.子进程会复直父进程全部的内存空间和代码段
2.子进程会从fork 的下一句开始执行

3.if  elif  else 结构正是根据父子进程fork的返回值不同让父子进程执行不同的内容
    几乎是fork的固定搭配
4.父子进程运行互不影响 使用同一个终端 运行顺序不定  
5.子进程有自己特有的pid pcb   命令集等

6.进入阻塞状态的进程一定会让出cpu时间片
7.子进程连同fork之前开辟的空间也会复制  但是父子进程各自空间独立 操作各自空间内容 互不影响



二.进程相关函数

os.getpid()
功能：获取当前pid号
返回值：返回PID号




os.getppid()
功能：获取父进程的pid号
返回值：返回 父进程PID号

os._exit(status)
功能：退出一个进程
参数：表示进程退出的状态


sys.exit([status])



功能：退出一个进程
参数：默认为0 整数表示进程退出状态
    字符串 则在进程退出时打印该字符串

三 孤儿进程和僵尸进程
    孤儿进程：父进程先予子进程退出，此时子进程称为孤儿进程（没有父进程）
                此时孤儿进程会被养父收养，此时系统进程就会成为该进程的新的父进程
    
    僵尸进程：子进程先于父进程退出父进程没有给父进程处理子进程的退出的状态 此时子进程就会成为僵尸进程

    * 僵尸进程虽然结束但是会留存部分pcb在内存 大量僵尸进程会占有内存资源

    如何处理僵尸进程

        1.在父进程中使用函数处理子进程退出状态
            pid，status = os.wait（）
            功能：阻塞等待处理子进程退出
            返回值： pid 退出的子进程的PID
                    status  子进程的退出状态

        pid，status= os.waitpid（pid，option）
        功能： 阻塞等待子进程退出
        参数：  pid  -1  表示等待任意子进程退出
                》0 等待指定pid的子进程退出
            返回值：pid退出的子进程的pid
                status  子进程的退出状态

            option 0  表示阻塞状态
                WNOHANG  表示非阻塞


    2.创建二级子进程
        【1】 父进程创建子进程等待子进程退出
        【2】 子进程创建二级子进程后立即退出
        【3】 将事件交由父进程和二级子进程完成
            一级子进程被回收  二级子进程成为孤儿
             都不会变成僵尸