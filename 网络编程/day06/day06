
1..进程相关的函数
os.getpid（）获取当前进程的pid
os.getppid（）  获取父进程的pid

os._exit（） 退出进程
sys.exit（）退出进程
2.孤儿和僵尸进程

如何避免僵尸进程
1.如何使用wait waitpid处理僵尸内容
2.创建二级子进程处理僵尸进程


---------------------------------------------------------------------------------------------\\
进程创建对象注意：
    * 如果父进程先创建对象再创建子进程 则子进程从父进程获取对象  此时父进程在对象操作上有一定的相互影响
        e.g 套接字会监听一个端口文件会有一个偏移量

    * 如果父进程先创建子进程 父子进程中各自创建的对象没有任何关联
    
    multiprocessing  模块创建进程
   1.将需要执行的进程事件封装为函数
   2.然后使用模块的process类生成进程对象 并关联函数
   3,可以通过对象的属性设置进程信息
   4，启动进程 执行绑定函数
   5，回收进程 

Process（）
功能： 创建进程对像
参数： target  必选  绑定的目标函数
     name   给进程起的名字 Process-1   
     args  元组  给target目标参数传参  位置传参
     kwargs 字典 给target目标寒素传参 键值传参



p.start（）
功能：启动进程

* target绑定的函数作为进程函数执行 进程被创建
p.join（【timeout】）
功能：阻塞等待回收进程


注意：
    * 使用multiprocessing创建进程，同样子进程复制父进程的全部代码段，父子进程执行互不影响，
     
      各自有各自的运行空间，子进程只执行函数部分*

    * join会回收子进程 否则会产生僵尸进程  如果设置超时 回收不到也会产生

    * multiprocessing中父进程往往只用来创建管理子进程具体时间由子进程完成
    

start struct target status


'进程对象属性
p.name进程名称
p.pid  进程pid号
p.is_alive() 查看进程状态 要么活  要么死
p.daemon         默认为False 表示主进程退出不会影响到子进程的执行  
                 如果设置为True 表示主进程退出时子进程也会退出      如:  p.daemon = True

                   * 必须在start前使用


自定义进程类
 

步骤:
    1.继承于Process类
    2.编写自己的__init__  添加自定义属性
        视同super重新加载父类__init__
    3.重写run方法

使用:
    1.使用自定义的类创建对象
    2.然后使用该对象调用start启动进程 此时会自动执行run函数
    3.使用该对象调用join()回收进程


进程池
    产生原因：如果有大量任务需要多进程完成 则可能需要频繁的创建删除过程 给计算机带来压力较大


原理：  创建进程池 放入一定量的进程 用来处理事件 
        事件处理完毕后 进程不会退出 而是继续等待处理其他事件
        直到所有待处理事件结束再统一销毁进程池 
        增加进程的重复利用 降低资源消耗



步骤： 1.创建进程池添加适当的进程
       2.将要完成的事件放入进程池等待队列
       3.不断取事件交由进程池中的进程完成 直到所有事件处理完毕
       4.关闭进程池 回收进程



from multiprocessing import Pool、
pool = Pool(processes)
功能： 创建进程池对象
参数：进程池中进程数量 默认根据系统自动判定

pool.apply_async(func,args,kwds)
功能：使用进程池中的进程执行函数事件
参数：func  要执行的函数
      args 元组 给func传参
      kwds  字典 给func键值传参
返回值：函数事件对象通过get（）方法可以获取func函数事件对象




pool.close（）
关闭进程池 不能再添加新的事件函数
poll.join（）
回收进程池



* 进程池事件func一定在进程池创建之前声明

pool.map(func,iter)
功能：将要做的事件加入到进程池执行、、
参数：func 要执行的函数
        iter 可迭代对象
    返回值：函数返回值列表  

进程间通信（IPC）
原因：通信空间相对独立 资源无法相互获取 此时在不同今晨间需要专门的方法进行通信


远程间的通信方法：管道 信息队列 共享内存 信号 信号量 套接字


管道通信（Pipe）

通信原理：
    在内存中开辟管道空间 生成管道操作对象 多个进程使用同一个管道对象读写即可实现通信

from multiprocessing import Pipe
fd1,fd2= Pipe（duplex = True）
功能：创建管道
参数：默认表示双向管道 如果设置为False 则表示单向管道

返回值： 表示管道的两端读写对象
        如果是双向管道均可读写
        如果是单向管道则fd1只读 fd2只写
fd.recv（）
功能：从管道读取内容 无内容则阻塞
返回值：读取到的内容

fd.send（data）
功能：向管道写入内容
参数：要写入的内容

消息队列：

队列：存储模型 线性的 先进先出原则


原理：在内存中建立队列模型 进程通过队列对象将消息存入队列 或从队列取出消息  完成进程间通信

from multiprocessing import Queue
q = Queue(maxsize)
功能：创建队列对象
参数：表示队列中最多存放消息个数
返回值：队列对象

q.put（data，【block，timeout】）
功能：向队列存入消息
参数：data 要存入的内容
    block 默认队列满时会阻塞 设置为False则为非阻塞
    timout  超时时间

q.get（【block，timeout】）
功能：从队列取出消息
参数： block 默认队列为空会阻塞 设置为False则非阻塞 
        timeout 超时时间
    返回值:取出的内容

q.full（） 判断队列是否为满
q.empty（） 判断队列是否为空
q.qsize（） 获取队列中消息个数
q.close（） 关闭队列


process  pool   Pipe  Queue

        进程池  管道读写  创建队列对象











